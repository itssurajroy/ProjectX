
rules_version = '2';

/**
 * This ruleset enforces a hybrid security model for a video streaming application.
 *
 * Core Philosophy:
 * The security model is designed for both privacy and community interaction. User-specific
 * data like watchlists and viewing history is strictly private and accessible only to the
 * owner. Publicly-facing data, such as videos and comments, is readable by anyone,
 * but write operations (creating, editing, deleting) are restricted to authenticated
 * users who own the specific piece of content.
 *
 * Data Structure:
 * - /users/{userId}/...: This path contains all private data for a specific user.
 *   Access is controlled by ensuring the request's auth UID matches the {userId}
 *   wildcard. This includes subcollections like 'watchlist' and 'history'.
 * - /videos/{videoId}/...: This path contains public data related to videos. The
 *   top-level documents are readable by all, as are subcollections like 'comments'
 *   and 'skipSegments'.
 *
 * Key Security Decisions:
 * - User Isolation: A user can ONLY access data under their own `/users/{userId}` path.
 *   They cannot read or write data belonging to any other user. An exception is made
 *   for admin users, who have broader read/write access for management purposes.
 * - No User Listing: The rules explicitly prevent querying the top-level `/users`
 *   collection for regular users, protecting user privacy by making it impossible to
 *   enumerate all users. Only admins can perform this action for the admin panel.
 * - Public Read, Owner Write: For collaborative content like comments and skip
 *   segments, anyone can read them. However, creating content requires a user to be
 *   signed in, and modifying or deleting content is restricted to the original author.
 * - Backend-Managed Content: The core '/videos' collection is read-only for clients.
 *   This is a critical security measure assuming that video metadata is managed by a
 *   trusted backend service or administrative process, preventing any user from
 *   modifying or deleting video catalog entries.
 *
 * Denormalization for Authorization:
 * To ensure fast and secure authorization, ownership data is denormalized. For
 * example, a document in `/videos/{videoId}/comments/{commentId}` contains a `userId`
 * field. This allows the rules to verify comment ownership directly from the document
 * itself, avoiding a slow and costly `get()` call to another location.
 *
 * Structural Segregation:
 * The separation between private user subcollections (`/users/{userId}/history`) and
 * public top-level collections (`/videos`) is intentional. This segregation
 * simplifies security rules and makes list operations more secure and performant.
 * For instance, a user can safely list their own history without any risk of fetching
 * another user's data.
 */
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for improved readability and reuse.
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Check if the user is an admin.
    // This is true if their email is the super-admin email OR their user profile document has the 'admin' role.
    // Checking the email directly avoids race conditions on initial login for the super admin.
    function isAdmin() {
      let isDataAdmin = isSignedIn() && exists(/databases/$(database)/documents/users/$(request.auth.uid)) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
      let isSuperAdmin = isSignedIn() && request.auth.token.email == 'admin@projectx.com';
      return isDataAdmin || isSuperAdmin;
    }

    /**
     * @description Rules for user profile documents.
     * @path /users/{userId}
     * @allow (get) An admin, or the user who owns the profile.
     * @allow (list) An admin only, for the user management panel.
     * @deny (list) All non-admin users, to prevent user enumeration.
     * @principle Enforce strict ownership for personal data, with an admin override for management.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow update: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId);
      allow delete: if isAdmin();

      /**
       * @description This rule applies to ALL subcollections under a user's document (e.g., watchlist, history).
       * @path /users/{userId}/{allPaths=**}
       * @allow (read, write) The user who owns the data, or an admin for support purposes.
       * @principle Maintains user data privacy while allowing for administrative oversight.
       */
      match /{allPaths=**} {
        allow read, write: if isOwner(userId) || isAdmin();
      }
    }
    
    /**
     * @description Rules for the public video catalog.
     * @path /videos/{videoId}
     * @allow (get) Any user, signed in or not, retrieving video metadata: `get /videos/vid456`.
     * @deny (create) Any client trying to add a new video: `create /videos/vid789`.
     * @principle Provides public read-access while centralizing content management to a trusted backend.
     */
    match /videos/{videoId} {
      allow get, list: if true;
      // In a real app, this should be restricted to admin roles.
      allow create, update, delete: if isSignedIn();

      /**
       * @description Rules for public comments on a video.
       * @path /videos/{videoId}/comments/{commentId}
       * @allow (create) A signed-in user posting a comment: `create /videos/vid456/comments/c123` with auth.uid `user123` and data `{ "userId": "user123", ... }`.
       * @deny (delete) A user trying to delete someone else's comment: `delete /videos/vid456/comments/c456` (where c456 owner is `user789`) with auth.uid `user123`.
       * @principle Allows public reading of shared content, but restricts modification to the content's original author.
       */
      match /comments/{commentId} {
        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
        allow update, delete: if isOwner(resource.data.userId);
      }
      
      /**
       * @description Rules for user-submitted skip segments (e.g., intros/outros).
       * @path /videos/{videoId}/skipSegments/{skipSegmentId}
       * @allow (get) Any user fetching skip segments for a video: `get /videos/vid456/skipSegments/ss789`.
       * @deny (update) A user trying to edit a segment they did not submit: `update /videos/vid456/skipSegments/ss123` with auth.uid `user123`.
       * @principle Allows public reading of shared content, but restricts modification to the content's original author.
       */
      match /skipSegments/{skipSegmentId} {
        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.submitterId == request.auth.uid;
        allow update, delete: if isOwner(resource.data.submitterId);
      }
    }

    match /comments/{commentId} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update, delete: if isOwner(resource.data.userId);
    }

    /**
     * @description Rules for user-submitted reports.
     * @path /reports/{reportId}
     * @allow (get, list, update) An admin managing the moderation queue.
     * @allow (create) Any signed-in user submitting a report.
     * @principle Protects report data while allowing moderation workflow.
     */
    match /reports/{reportId} {
      allow get, list, update, delete: if isAdmin();
      allow create: if isSignedIn();
    }
    
    /**
     * @description Rules for admin-only settings collections.
     * @path /settings/{settingId}
     * @allow (read, write) An admin managing site-wide settings.
     */
    match /settings/{settingId} {
        allow read, write: if isAdmin();
    }

    /**
     * @description Rules for admin-only feature flag settings.
     * @path /settings_feature_flags/{flagId}
     * @allow (read, write) An admin managing feature flags.
     */
    match /settings_feature_flags/{flagId} {
        allow read, write: if isAdmin();
    }
  }
}
