
rules_version = '2';

/**
 * This ruleset enforces a hybrid security model for a video streaming application.
 *
 * Core Philosophy:
 * The security model is designed for both privacy and community interaction. User-specific
 * data like watchlists and viewing history is strictly private and accessible only to the
 * owner. Publicly-facing data, such as videos and comments, is readable by anyone,
 * but write operations (creating, editing, deleting) are restricted to authenticated
 * users who own the specific piece of content.
 *
 * Data Structure:
 * - /users/{userId}/...: This path contains all private data for a specific user.
 *   Access is controlled by ensuring the request's auth UID matches the {userId}
 *   wildcard. This includes subcollections like 'watchlist' and 'history'.
 * - /videos/{videoId}/...: This path contains public data related to videos. The
 *   top-level documents are readable by all, as are subcollections like 'comments'
 *   and 'skipSegments'.
 *
 * Key Security Decisions:
 * - User Isolation: A user can ONLY access data under their own `/users/{userId}` path.
 *   They cannot read or write data belonging to any other user.
 * - No User Listing: The rules explicitly prevent querying the top-level `/users`
 *   collection, protecting user privacy by making it impossible to enumerate all
 *   users in the system.
 * - Public Read, Owner Write: For collaborative content like comments and skip
 *   segments, anyone can read them. However, creating content requires a user to be
 *   signed in, and modifying or deleting content is restricted to the original author.
 * - Backend-Managed Content: The core '/videos' collection is read-only for clients.
 *   This is a critical security measure assuming that video metadata is managed by a
 *   trusted backend service or administrative process, preventing any user from
 *   modifying or deleting video catalog entries.
 *
 * Denormalization for Authorization:
 * To ensure fast and secure authorization, ownership data is denormalized. For
 * example, a document in `/videos/{videoId}/comments/{commentId}` contains a `userId`
 * field. This allows the rules to verify comment ownership directly from the document
 * itself, avoiding a slow and costly `get()` call to another location.
 *
 * Structural Segregation:
 * The separation between private user subcollections (`/users/{userId}/history`) and
 * public top-level collections (`/videos`) is intentional. This segregation
 * simplifies security rules and makes list operations more secure and performant.
 * For instance, a user can safely list their own history without any risk of fetching
 * another user's data.
 */
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for improved readability and reuse.
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    match /users/{userId} {
      // Users can only read and write to their own document.
      // This prevents users from reading other users' profiles or creating profiles for others.
      allow read, update, create: if request.auth.uid == userId;
      // User profiles cannot be listed by clients. This prevents user enumeration.
      allow list: if false;
      // Profiles cannot be deleted by clients.
      allow delete: if false;

      // This rule applies to ALL subcollections under a user's document (e.g., watchlist, history, favoriteCharacters).
      // It ensures that a user can only access their own subcollections.
      match /{allPaths=**} {
        allow read, write: if request.auth.uid == userId;
      }
    }
    
    /**
     * @description Rules for the public video catalog.
     * @path /videos/{videoId}
     * @allow (get) Any user, signed in or not, retrieving video metadata: `get /videos/vid456`.
     * @deny (create) Any client trying to add a new video: `create /videos/vid789`.
     * @principle Provides public read-access while centralizing content management to a trusted backend.
     */
    match /videos/{videoId} {
      allow get, list: if true;
      // In a real app, this should be restricted to admin roles.
      allow create, update, delete: if isSignedIn();

      /**
       * @description Rules for public comments on a video.
       * @path /videos/{videoId}/comments/{commentId}
       * @allow (create) A signed-in user posting a comment: `create /videos/vid456/comments/c123` with auth.uid `user123` and data `{ "userId": "user123", ... }`.
       * @deny (delete) A user trying to delete someone else's comment: `delete /videos/vid456/comments/c456` (where c456 owner is `user789`) with auth.uid `user123`.
       * @principle Allows public reading of shared content, but restricts modification to the content's original author.
       */
      match /comments/{commentId} {
        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
        allow update, delete: if isOwner(resource.data.userId);
      }
      
      /**
       * @description Rules for user-submitted skip segments (e.g., intros/outros).
       * @path /videos/{videoId}/skipSegments/{skipSegmentId}
       * @allow (get) Any user fetching skip segments for a video: `get /videos/vid456/skipSegments/ss789`.
       * @deny (update) A user trying to edit a segment they did not submit: `update /videos/vid456/skipSegments/ss123` with auth.uid `user123`.
       * @principle Allows public reading of shared content, but restricts modification to the content's original author.
       */
      match /skipSegments/{skipSegmentId} {
        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.submitterId == request.auth.uid;
        allow update, delete: if isOwner(resource.data.submitterId);
      }
    }

    match /comments/{commentId} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update, delete: if isOwner(resource.data.userId);
    }
  }
}
