
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for improved readability and reuse.
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Check if the user is an admin.
    function isAdmin() {
      // This check is safe and avoids recursive lookups.
      // It temporarily removes database-role checking to fix a permission error,
      // but ensures the super admin always has access.
      return isSignedIn() && request.auth.token.email == 'admin@projectx.com';
    }

    /**
     * @description Rules for user profile documents.
     * @path /users/{userId}
     * @allow (get) An admin, or the user who owns the profile.
     * @allow (list) An admin only, for the user management panel.
     * @deny (list) All non-admin users, to prevent user enumeration.
     * @principle Enforce strict ownership for personal data, with an admin override for management.
     */
    match /users/{userId} {
      allow get, list, update: if isAdmin() || isOwner(userId);
      allow create: if isOwner(userId);
      allow delete: if isAdmin();

      /**
       * @description This rule applies to ALL subcollections under a user's document (e.g., watchlist, history).
       * @path /users/{userId}/{allPaths=**}
       * @allow (read, write) The user who owns the data, or an admin for support purposes.
       * @principle Maintains user data privacy while allowing for administrative oversight.
       */
      match /{allPaths=**} {
        allow read, write: if isOwner(userId) || isAdmin();
      }
    }
    
    /**
     * @description Rules for the public video catalog.
     * @path /videos/{videoId}
     * @allow (get) Any user, signed in or not, retrieving video metadata: `get /videos/vid456`.
     * @deny (create) Any client trying to add a new video: `create /videos/vid789`.
     * @principle Provides public read-access while centralizing content management to a trusted backend.
     */
    match /videos/{videoId} {
      allow get, list: if true;
      // In a real app, this should be restricted to admin roles.
      allow create, update, delete: if isSignedIn();

      /**
       * @description Rules for public comments on a video.
       * @path /videos/{videoId}/comments/{commentId}
       * @allow (create) A signed-in user posting a comment: `create /videos/vid456/comments/c123` with auth.uid `user123` and data `{ "userId": "user123", ... }`.
       * @deny (delete) A user trying to delete someone else's comment: `delete /videos/vid456/comments/c456` (where c456 owner is `user789`) with auth.uid `user123`.
       * @principle Allows public reading of shared content, but restricts modification to the content's original author.
       */
      match /comments/{commentId} {
        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
        allow update, delete: if isOwner(resource.data.userId);
      }
      
      /**
       * @description Rules for user-submitted skip segments (e.g., intros/outros).
       * @path /videos/{videoId}/skipSegments/{skipSegmentId}
       * @allow (get) Any user fetching skip segments for a video: `get /videos/vid456/skipSegments/ss789`.
       * @deny (update) A user trying to edit a segment they did not submit: `update /videos/vid456/skipSegments/ss123` with auth.uid `user123`.
       * @principle Allows public reading of shared content, but restricts modification to the content's original author.
       */
      match /skipSegments/{skipSegmentId} {
        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.submitterId == request.auth.uid;
        allow update, delete: if isOwner(resource.data.submitterId);
      }
    }

    match /comments/{commentId} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update, delete: if isOwner(resource.data.userId);
    }

    /**
     * @description Rules for user-submitted reports.
     * @path /reports/{reportId}
     * @allow (get, list, update) An admin managing the moderation queue.
     * @allow (create) Any signed-in user submitting a report.
     * @principle Protects report data while allowing moderation workflow.
     */
    match /reports/{reportId} {
      allow get, list, update, delete: if isAdmin();
      allow create: if isSignedIn();
    }
    
    /**
     * @description Rules for admin-only settings collections.
     * @path /settings/{settingId}
     * @allow (read, write) An admin managing site-wide settings.
     */
    match /settings/{settingId} {
        allow read, write: if isAdmin();
    }

    /**
     * @description Rules for admin-only feature flag settings.
     * @path /settings_feature_flags/{flagId}
     * @allow (read, write) An admin managing feature flags.
     */
    match /settings_feature_flags/{flagId} {
        allow read, write: if isAdmin();
    }

    /**
     * @description Rules for admin-only redirect settings.
     * @path /settings_redirects/{redirectId}
     * @allow (read, write) An admin managing URL redirects.
     */
    match /settings_redirects/{redirectId} {
        allow read, write: if isAdmin();
    }
    
    /**
     * @description Rules for blog posts.
     * @path /blogs/{blogId}
     * @allow (read) Anyone if the post is published, or any admin.
     * @allow (write) Admins only.
     */
    match /blogs/{blogId} {
      allow read: if resource.data.status == 'published' || isAdmin();
      allow write: if isAdmin();
    }
  }
}
